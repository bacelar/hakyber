///////////////////////////////////////////////////////////////////////////////
// TODO: when integrating in libjade, replace following statement with:
// from Jade require "common/keccak/keccak1600/amd64/spec/keccakf1600.jinc"

require "keccakf1600.jinc" // r = __rhotates(x_, y_);

///////////////////////////////////////////////////////////////////////////////

require "fips202_common.jinc"

param int KECCAK_ROUNDS=24;

u256[24] KECCAK1600_RC_4x = {
  (4u64)[0x0000000000000001, 0x0000000000000001, 0x0000000000000001, 0x0000000000000001],
  (4u64)[0x0000000000008082, 0x0000000000008082, 0x0000000000008082, 0x0000000000008082],
  (4u64)[0x800000000000808a, 0x800000000000808a, 0x800000000000808a, 0x800000000000808a],
  (4u64)[0x8000000080008000, 0x8000000080008000, 0x8000000080008000, 0x8000000080008000],
  (4u64)[0x000000000000808b, 0x000000000000808b, 0x000000000000808b, 0x000000000000808b],
  (4u64)[0x0000000080000001, 0x0000000080000001, 0x0000000080000001, 0x0000000080000001],
  (4u64)[0x8000000080008081, 0x8000000080008081, 0x8000000080008081, 0x8000000080008081],
  (4u64)[0x8000000000008009, 0x8000000000008009, 0x8000000000008009, 0x8000000000008009],
  (4u64)[0x000000000000008a, 0x000000000000008a, 0x000000000000008a, 0x000000000000008a],
  (4u64)[0x0000000000000088, 0x0000000000000088, 0x0000000000000088, 0x0000000000000088],
  (4u64)[0x0000000080008009, 0x0000000080008009, 0x0000000080008009, 0x0000000080008009],
  (4u64)[0x000000008000000a, 0x000000008000000a, 0x000000008000000a, 0x000000008000000a],
  (4u64)[0x000000008000808b, 0x000000008000808b, 0x000000008000808b, 0x000000008000808b],
  (4u64)[0x800000000000008b, 0x800000000000008b, 0x800000000000008b, 0x800000000000008b],
  (4u64)[0x8000000000008089, 0x8000000000008089, 0x8000000000008089, 0x8000000000008089],
  (4u64)[0x8000000000008003, 0x8000000000008003, 0x8000000000008003, 0x8000000000008003],
  (4u64)[0x8000000000008002, 0x8000000000008002, 0x8000000000008002, 0x8000000000008002],
  (4u64)[0x8000000000000080, 0x8000000000000080, 0x8000000000000080, 0x8000000000000080],
  (4u64)[0x000000000000800a, 0x000000000000800a, 0x000000000000800a, 0x000000000000800a],
  (4u64)[0x800000008000000a, 0x800000008000000a, 0x800000008000000a, 0x800000008000000a],
  (4u64)[0x8000000080008081, 0x8000000080008081, 0x8000000080008081, 0x8000000080008081],
  (4u64)[0x8000000000008080, 0x8000000000008080, 0x8000000000008080, 0x8000000000008080],
  (4u64)[0x0000000080000001, 0x0000000080000001, 0x0000000080000001, 0x0000000080000001],
  (4u64)[0x8000000080008008, 0x8000000080008008, 0x8000000080008008, 0x8000000080008008]
};

u256 ROL56 = 0x181F1E1D1C1B1A191017161514131211080F0E0D0C0B0A090007060504030201;
u256 ROL8  = 0x1E1D1C1B1A19181F16151413121110170E0D0C0B0A09080F0605040302010007;

// C[x] = A[x,0] ^ A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
inline fn __theta_sum_4x_avx2(reg ptr u256[25] a) -> reg u256[5]
{
  inline int x y;
  reg u256[5] c;

  // C[x] = A[x, 0]
  for x=0 to 5
  { c[x] = a[x + 0]; }

  // C[x] ^= A[x,1] ^ A[x,2] ^ A[x,3] ^ A[x,4]
  for y=1 to 5
  { for x=0 to 5
    { c[x] ^= a[x + y*5]; }
  }

  return c;
}

inline fn __rol_4x_avx2(reg u256[5] a, inline int x r, reg u256 r8 r56) -> reg u256[5]
{
	reg u256 t;

  if(r == 8)
  {	a[x] = #VPSHUFB_256(a[x], r8); }
  else { if(r == 56)
  { a[x] = #VPSHUFB_256(a[x], r56); }
  else
  { t     = #VPSLL_4u64(a[x], r);
	  a[x]  = #VPSRL_4u64(a[x], 64 - r);
	  a[x] |= t; }
  }

	return a; 
}

// D[x] = C[x-1] ^ ROT(C[x+1], 1) 
inline fn __theta_rol_4x_avx2(reg u256[5] c, reg u256 r8 r56) -> reg u256[5]
{
  inline int x;
  reg u256[5] d;

  for x = 0 to 5
  { // D[x] = C[x + 1]
    d[x] = c[(x + 1) % 5];

    // D[x] = ROT(D[x], 1)
    d = __rol_4x_avx2(d, x, 1, r8, r56);

    // D[x] ^= C[x-1]
    d[x] ^= c[(x - 1 + 5) % 5];
  }

  return d;
}


// B[x] = ROT( (A[x',y'] ^ D[x']), r[x',y'] ) with (x',y') = M^-1 (x,y)
//
// M = (0 1)  M^-1 = (1 3)  x' = 1x + 3y
//     (2 3)         (1 0)  y' = 1x + 0y
//
inline fn __rol_sum_4x_avx2(
  reg ptr u256[25] a,
  reg u256[5] d,
  inline int y,
  reg u256 r8 r56
) -> reg u256[5]
{
  inline int r x x_ y_;
  reg u256[5] b;

  for x = 0 to 5
  {
    x_ = (x + 3*y) % 5;
    y_ = x;
    r = __rhotates(x_, y_);

    // B[x] = A[x',y']
    b[x] = a[x_ + y_*5];

    // B[x] ^= D[x'];
    b[x] ^= d[x_];

    // B[x] = ROT( B[x], r[x',y'] );
    if(r != 0)
    { b = __rol_4x_avx2(b, x, r, r8, r56); }
  }

  return b;
}


// E[x, y] = B[x] ^ ( (!B[x+1]) & B[x+2] )
// -- when x and y are 0: E[0,0] ^= RC[i];
inline fn __set_row_4x_avx2(
  reg ptr u256[25] e,
  reg u256[5] b,
  inline int y,
  reg u256 rc
) -> reg ptr u256[25]
{
  inline int x x1 x2;
  reg u256 t;

  for x=0 to 5
  { 
    x1 = (x + 1) % 5;
    x2 = (x + 2) % 5;

    t = #VPANDN_256(b[x1], b[x2]);

    t ^= b[x];
    if( x==0 && y==0 ){ t ^= rc; }
    e[x + y*5] = t;
  }

  return e;
}


inline fn __round_4x_avx2(reg ptr u256[25] e a, reg u256 rc r8 r56) -> reg ptr u256[25]
{
  inline int y;
  reg u256[5] b c d;

  c = __theta_sum_4x_avx2(a);
  d = __theta_rol_4x_avx2(c, r8, r56);

  for y = 0 to 5
  { b = __rol_sum_4x_avx2(a, d, y, r8, r56);
    e = __set_row_4x_avx2(e, b, y, rc);
  }

  return e;
}


inline fn __keccakf1600_4x_avx2(reg ptr u256[25] a) -> reg ptr u256[25]
{
  reg ptr u256[24] RC;
  stack u256[25] s_e;
  reg ptr u256[25] e;
  reg u256 rc r8 r56;
  reg u64 c;

  e = s_e;
  RC = KECCAK1600_RC_4x;

  r8 = ROL8;
  r56 = ROL56;

  c = 0;
  while
  {
    rc = RC.[(int) c];
    e = __round_4x_avx2(e, a, rc, r8, r56);

    rc = RC.[(int) c + 32];
    a = __round_4x_avx2(a, e, rc, r8, r56);

    c += 64;
  } (c < (KECCAK_ROUNDS*32))

  return a;
}

fn _keccakf1600_4x_avx2(reg ptr u256[25] a) -> reg ptr u256[25]
{
  a = __keccakf1600_4x_avx2(a);
  return a;
}

// ////////////////////////////////////////////////////////////////////////////

fn _shake128_absorb4x_34(
  reg ptr u256[25] s,
  reg ptr u8[34] m0 m1 m2 m3)
  ->
  reg ptr u256[25]
{
	inline int i;
  reg u256 t0 t1;
  reg u16 t16;
	reg u64 t64;

  for i = 0 to 25
  {
    t0 = #set0_256();
    s[i] = t0;
  }

	for i = 0 to 4
  {
    t64 = m0[u64 i];
    s[u64 4 * i] ^= t64;
    t64 = m1[u64 i];
    s[u64 4 * i + 1] ^= t64;
    t64 = m2[u64 i];
    s[u64 4 * i + 2] ^= t64;
    t64 = m3[u64 i];
    s[u64 4 * i + 3] ^= t64;
  }

  t16 = m0.[u16 32];
  s[u16 64] ^= t16;
  s[u8 130] ^= 0x1F;

  t16 = m1.[u16 32];
  s[u16 68] ^= t16;
  s[u8 138] ^= 0x1F;

  t16 = m2.[u16 32];
  s[u16 72] ^= t16;
  s[u8 146] ^= 0x1F;

  t16 = m3.[u16 32];
  s[u16 76] ^= t16;
  s[u8 154] ^= 0x1F;

  t0 = shake_sep[u256 0];
  t1 = s[SHAKE128_RATE / 8 - 1];
  t0 = t0 ^ t1;
  s[SHAKE128_RATE / 8 - 1] = t0;

	return s;
}


inline
fn __shake128_squeezeblock4x(
  reg ptr u256[25] state,
  reg ptr u8[SHAKE128_RATE] h0 h1 h2 h3)
  ->
  reg ptr u256[25],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE],
  reg ptr u8[SHAKE128_RATE]
{
  reg u256 t256;
  reg u128 t128;
  inline int i;

  state = _keccakf1600_4x_avx2(state);

	for i = 0 to (SHAKE128_RATE / 8) {
    t256 = state[i];
    t128 = (128u)t256;
		h0[u64 i] = #VMOVLPD(t128);
		h1[u64 i] = #VMOVHPD(t128);
    t128 = #VEXTRACTI128(t256, 1);
		h2[u64 i] = #VMOVLPD(t128);
		h3[u64 i] = #VMOVHPD(t128);
	}

  return state, h0, h1, h2, h3;
}

// ////////////////////////////////////////////////////////////////////////////

fn _shake256_absorb4x_33(
  reg ptr u256[25] s,
  reg ptr u8[33] m0 m1 m2 m3)
  ->
  reg ptr u256[25]
{
	inline int i;
  reg u256 t0 t1;
	reg u64 t64;
  reg u8 t8;

  for i = 0 to 25
  {
    t0 = #set0_256();
    s[i] = t0;
  }

	for i = 0 to 4
  {
    t64 = m0[u64 i];
    s[u64 4 * i] ^= t64;
    t64 = m1[u64 i];
    s[u64 4 * i + 1] ^= t64;
    t64 = m2[u64 i];
    s[u64 4 * i + 2] ^= t64;
    t64 = m3[u64 i];
    s[u64 4 * i + 3] ^= t64;
  }

  t8 = m0[32];
  s[u8 128] ^= t8;
  s[u8 129] ^= 0x1F;

  t8 = m1[32];
  s[u8 136] ^= t8;
  s[u8 137] ^= 0x1F;

  t8 = m2[32];
  s[u8 144] ^= t8;
  s[u8 145] ^= 0x1F;

  t8 = m3[32];
  s[u8 152] ^= t8;
  s[u8 153] ^= 0x1F;

  t0 = shake_sep[u256 0];
  t1 = s[SHAKE256_RATE / 8 - 1];
  t0 = t0 ^ t1;
  s[SHAKE256_RATE / 8 - 1] = t0;

	return s;
}


inline
fn __shake256_squeezeblock4x(
  reg ptr u256[25] state,
  reg ptr u8[SHAKE256_RATE] h0 h1 h2 h3)
  ->
  reg ptr u256[25],
  reg ptr u8[SHAKE256_RATE],
  reg ptr u8[SHAKE256_RATE],
  reg ptr u8[SHAKE256_RATE],
  reg ptr u8[SHAKE256_RATE]
{
  reg u256 t256;
  reg u128 t128;
  inline int i;

  state = _keccakf1600_4x_avx2(state);

	for i = 0 to (SHAKE256_RATE / 8) {
    t256 = state[i];
    t128 = (128u)t256;
		h0[u64 i] = #VMOVLPD(t128);
		h1[u64 i] = #VMOVHPD(t128);
    t128 = #VEXTRACTI128(t256, 1);
		h2[u64 i] = #VMOVLPD(t128);
		h3[u64 i] = #VMOVHPD(t128);
	}

  return state, h0, h1, h2, h3;
}
